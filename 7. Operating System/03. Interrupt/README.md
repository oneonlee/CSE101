# Interrupt

- What is Interrupt
- interrupt number
- handling interrupt
- interrupt service routine: ISR
  - ISR1, ISR2
- OS = initialization code + collection of ISR's

An operating system is a collection of service routines. The service routine can be executed by a request from an application (**system call interrupt**). <br>
Or it runs automatically when there is a serious error while running an application (**exception interrupt**) or when there is an external hardware event that the operating system has to handle (**hardware interrupt**). <br>
The service routines are called ISRs (Interrupt Service Routines).

| external event                        | interrupt number            | ISR (ISR1 => ISR2)                      |
| ------------------------------------- | --------------------------- | --------------------------------------- |
| An application calls<br> `read(...)`  | int 128<br> (syscall num 3) | `system_call()` => `sys_read()`         |
| An application calls<br> `write(...)` | int 128<br> (syscall num 4) | `system_call()` => `sys_write()`        |
| timer ticks                           | int 32                      | `interrupt[0]` => `timer_interrupt()`   |
| key stroke                            | int 33                      | `interrupt[1]` => `atkbd_interrupt()`   |
| An application runs<br> `x=x/0;`      | int 0                       | `divide_error(`) => `do_divide_error()` |
| page fault while an application run   | int 14                      | `page_fault()` => `do_page_fault()`     |

ISR1s are all located in `arch/x86/kernel/entry_32.S`. <br>
ISR2s are located in various locations of the kernel.

When an interrupt, INT x, happens, the cpu stores the current cs, eip, flag register into stack and jumps to ISR1 for INT x. <br>
The ISR1 locations are written in IDT (Interrupt Descriptor Table), and the cpu jumpts to the location written in `IDT[x]`. <br>
ISR1 knows the location of ISR2. <br>
It knows the location of ISR2 because it is hard-coded (exception interrupt case), or is written in irq_desc table (hardware interrupt case) or is written in syscall_table (system call interrupt case).

## 1. Interrupt classification and Interrupt number

- There are two kinds of interrupt:
  - **software interrupt**
  - and **hardware interrupt**.<br><br>
- **Software interrupt** is generated by a program when it makes a serious error (e.g. dividing by zero) or runs a special instruction (e.g. INT, SYSENTER, SYSCALL).
  - The former is called **exception** and the latter **system call**.
- **Hardware interrupt** is generated by peripheral devices connected to CPU.
  - Key press is one example of hardware interrupt. <br><br>
- All interrupts have a unique number defined by the operating system.
- Operating system is a collection of routines that handle interrupts.

**Hardware interrupts** have been assigned following interrupt numbers in Linux.

| device                  | interrupt number | irq number |
| ----------------------- | ---------------- | ---------- |
| timer                   | 32               | 0          |
| keyboard                | 33               | 1          |
| PIC cascading           | 34               | 2          |
| second serial port      | 35               | 3          |
| first serial port       | 36               | 4          |
| floppy disk             | 38               | 6          |
| system clock            | 40               | 8          |
| network interface       | 42               | 10         |
| usb port, sound card    | 43               | 11         |
| ps/2 mouse              | 44               | 12         |
| math coprocessor        | 45               | 13         |
| eide disk, first chain  | 46               | 14         |
| eide disk, second chain | 47               | 15         |

**Exceptions** have been assigned following interrupt numbers.

| exception                   | interrupt number |
| --------------------------- | ---------------- |
| divide-by-zero error        | 0                |
| debug                       | 1                |
| NMI                         | 2                |
| breakpoint                  | 3                |
| overflow                    | 4                |
| bounds check                | 5                |
| invalid opcode              | 6                |
| device not available        | 7                |
| double fault                | 8                |
| coprocessor segment overrun | 9                |
| invalid TSS                 | 10               |
| segment not present         | 11               |
| stack segment fault         | 12               |
| general protection          | 13               |
| page fault                  | 14               |
| intel-reserved              | 15               |
| floating point error        | 16               |
| alignment check             | 17               |
| machine check               | 18               |
| simd floating point         | 19               |

Finally, **system calls** in Linux are all assigned the same interrupt number, **128 (`0x80`)**. To differentiate between different system calls, a unique system call number has been given to each system call. For the full table, look at **`arch/x86/kernel/syscall_table_32.S`**.

| system calls | interrupt number | system call number |
| ------------ | ---------------- | ------------------ |
| exit         | 128              | 1                  |
| fork         | 128              | 2                  |
| read         | 128              | 3                  |
| write        | 128              | 4                  |
| open         | 128              | 5                  |
| close        | 128              | 6                  |
| ......       | ......           | ......             |

## 2. How interrupts are detected?

Interrupts are detected by CPU. Exceptions are detected when the corresponding error happens. System calls are detected when the program executes INT 128 instruction. Hardware interrupts are detected when the corresponding devices are affected. Hardware interrupts need more detailed explanation.

![](img/hw-interrupts.png)

The above picture shows how hardware interrupts are detected by the CPU. All hardware devices are connected to 8259A interrupt controller through IRQ lines. Timer is connected through IRQ0 line, keyboard is connected through IRQ1 line, and so on. When an event happens in one of these devices, the corresponding IRQ line is activated, and 8259A signals CPU about this event along with the corresponding interrupt number for this IRQ line. The interrupt number is computed as (IRQ line number + 32) in Linux.

## 3. How interrupts are handled

Interrupts are first handled by the CPU, and then the operating system takes care of the rest of things.

### 3.1 cpu part

- When an interrupt happens, the CPU executes the corresponding INT instruction.
- For example, if the user presses a key (which corresponds to INT 33), the CPU executes INT 33.
- Executing `INT x` instruction is two steps:
  - save current EFLAG, CS,EIP registers in the stack
  - jump to the location specified in `IDT[x]`<br><br>
- IDT(Interrupt Descriptor Table) is a table containing the address of ISR’s(Interrupt Service Routines).
- More general name for IDT is Interrupt Vector Table. If `IDT[32]` indicates address `0x10200`, the ISR for timer interrupt is located at address `0x10200`, which means whenever the timer ticks, the cpu jumps to address `0x10200`.
- If `IDT[33]` indicates address `0x10300`, the ISR for keyboard is located at `0x10300`.
- Whenever the user hits some key, the cpu will jump to `0x10300` and start to execute whatever program stored there.<br><br>
- It is the responsibility of the operating system to provide the IDT and fill in proper address for each interrupt.
- Linux writes IDT in **`arch/x86/kernel/traps_32.c/trap_init()`** (for exception interrupts and system call interrupt) and in **`arch/x86/kernel/i8259_32.c/init_IRQ()`** (for hardware interrupts).
- Also the cpu knows the location of IDT by its IDTR register.
- Therefore, it is again the responsibility of operating system to write the location of the IDT in IDTR register.
- Each entry in IDT is 8 byte.
- The variable name of IDT table in Linux is idt_table.

### 3.2 OS part

- Once the cpu jumps to the corresponding ISR, OS takes the control since ISR belongs to the operating system.
- All ISR’s (I call ISR1) consist of three steps:
  - save the rest of registers (eflag, cs, eip are already saved by cpu)
  - call actual interrupt handler (I call ISR2)
  - recover the saved registers and go back to the interrupted location
- Linux writes ISR1's in IDT by calling `set_intr_gate()` for hardware interrupts in `arch/x86/kernel/i8259_32.c/native_init_IRQ()`, and by calling `set_trap_gate()` for most of the exceptions and `set_system_gate()` for system call interrupts in `arch/x86/kernel/traps_32.c/trap_init()`.
- Device drivers write their ISR2's for hardware interrupts in `irq_desc[]` table by calling `request_irq()`.
- ISR2's for exceptions are directly called in the corresponding ISR1's, the name always being do\_(ISR1 name). - ISR2's for the system calls are hard-coded in `sys_call_table[]` in `arch/x86/kernel/syscall_table_32.S`.
- ISR1s are defined in `arch/x86/kernel/entry_32.S`, and ISR2s are defined in various places.

![](img/idt_table.png)

Interrupt numbers and their ISR1 and ISR2 list.

| interrupt number        | ISR1         | ISR2            |
| ----------------------- | ------------ | --------------- |
| 0                       | divide_error | do_divide_error |
| 1                       | debug        | do_debug        |
| ...............         |              |                 |
| 32                      | interrupt[0] | timer_interrupt |
| 33                      | interrupt[1] | atkbd_interrupt |
| ................        |              |                 |
| 128 (syscall num 1)     | system_call  | sys_exit        |
| 128 (syscall num 2)     | system_call  | sys_fork        |
| ....................... |              |                 |

## 4. Creating a new system call and using it

Creating a new system call : 2 steps

- find empty `sys_call_table` entry (`sys_ni_syscall`) : `x`
- 1. write new system call name: `my_syscall`
- 2. define `my_syscall` (in appropriate file such as `fs/read_write.c`)
  ```c
  asmlinkage void my_syscall(){
      printk("hello from my_syscall\n");
  }
  ```
- recompile and reboot

### Using `ex1.c`:

```c
void main(){
  syscall(x);
}
```

### `./ex1`

```
==> syscall(x)
==> mov eax, x
       int   0x80
==> system_call
==> my_syscall
```

## 5. Exercise

### 1) Following events will cause interrupts in the system. What interrupt number will be assigned to each event? For system call interrupt, also give the system call number.

- A packet has arrived
  - network interface : 42
- An application program calls `scanf()`
  - `system_call()` => `sys_read()(3)` : 128
- A key is pressed
  - `interrupt[1]` : 33
- An application causes a divide-by-zero error
  - Exception interrupt : 0
- An application program calls `printf()`
  - `system_call()` => `sys_read()(3)` :128
- An application causes a page-fault error
  - `page_fault()` => `do_page_fault()` :14

## 2) Change `drivers/input/keyboard/atkbd.c` as follows.

```bash
$ vi drivers/input/keyboard/atkbd.c
```

```c
static irqreturn_t atkbd_interrupt(....){
   return IRQ_HANDLED;  // Add this at the first line
   .............
}
```

![](img/2-atkbd.png)

#### Recompile the kernel and reboot with it.

```bash
$ make bzImage
$ cp arch/x86/boot/bzImage /boot/bzImage
$ reboot
```

#### What happens and why does this happen? Show the sequence of events that happen when you hit a key in a normal Linux kernel (as detail as possible): hit a key => keyboard controller sends a signal through IRQ line 1 => ......etc. Now with the changed Linux kernel show which step in this sequence has been modified and prevents the kernel to display the pressed key in the monitor.

![](img/2-booting.png)

부팅이 끝나면 로그인 입력이 출력되지만, Keyboard action이 먹히지 않는다.

원래 코드는interrupt가 발생 후, 키보드 입력과정을 처리한 뒤 `IRQ_HANDLED`를 리턴하는데, 이 과정들을 거치지 않고 바로 리턴하도록 했기 때문에, 어떤 문자를 입력해도 실행이 되지 않는다.

### 3) Change the kernel such that it prints "x pressed" for each key pressing, where x is the scan code of the key. After you change the kernel and reboot it, do followings to see the effect of your changing.

```bash
$ vi drivers/input/keyboard/atkbd.c
```

`code`를 `printk`로 출력할 수 있도록 `printk("%x pressed\n", code);`를 추가하였다.

`drivers/input/keyboard/atkbd.c`:
![](img/3-atkbd.png)

이후, 컴파일하고 재부팅하여 새로운 리눅스 커널을 적용하였다.

```bash
$ cat /proc/sys/kernel/printk
1  4  1  7
```

위는 현재의 콘솔 로그 레벨, 기본 로그 레벨, 최소 로그 레렐, 최대 로그 레벨을 나타낸다. 현재는 `1`로 기본 레벨보다 낮기 때문에 `printk()`로 출력되는 문자들이 화면에 나타나지 않는다.

```bash
$ echo 8 > /proc/sys/kernel/printk
```

위 명령으로 현재 콘솔 로그 레벨을 `8`로 바꾸면 아래와 같이 레벨이 바뀐다.

```bash
$ cat /proc/sys/kernel/printk
8   4   1   7
```

현재는 레벨이 `8`이기 때문에 `printk`로 출력되는 문자들이 화면에 보인다. 위와 같이 입력되는 키 코드가 화면에 보인다.

```bash
$ echo 1 > /proc/sys/kernel/printk
```

`printk` 출력을 보이지 않게 하려면 현재 로그 레벨을 `1`로 되돌리면 된다.

![](img/3-printk.png)

### 4) Change the kernel such that it displays the next character in the keyboard scancode table. For example, when you type "root", the monitor would display "tppy". How can you log in as root with this kernel?

```bash
$ vi drivers/input/keyboard/atkbd.c
```

키보드 입력이 들어오면, 실제 입력한 글자의 다음 글자를 입력한 것으로 처리하도록 `unsigned int code = data;`를 `unsigned int code = data+1;`로 수정하였다.

`drivers/input/keyboard/atkbd.c`:
![](img/4-atkbd.png)

이후, 컴파일하고 재부팅하여 새로운 리눅스 커널을 적용하였다.

![](img/4-root.png)

재부팅하고 로그인을 하기 위해 "root"를 입력하면 키보드에서 한 글자씩 밀린 "tppy"가 출력된다.

### 5) Define a function `mydelay` in `init/main.c` which whenever called will stop the booting process until you hit 's'. Call this function after `do_basic_setup()` function call in `kernel_init()` in order to make the kernel stop and wait for 's' during the booting process. You need to modify `atkbd.c` such that it changes `exit_mydelay` to 1 when the user presses 's'.

<br>

`init/main.c` :

```c
........
int exit_mydelay;    // define a global variable
void mydelay(char *str){
   printk(str);
   printk("enter s to continue\n");
   exit_mydelay=0;  // init to zero
   for(;;){  // and wait here until the user press 's'
      msleep(1); // sleep 1 micro-second so that keyboard interrupt ISR
                 // can do its job
      if (exit_mydelay==1) break; // if the user press 's', break
   }
}
void kernel_init(){
    ...............
    do_basic_setup();
    mydelay("after do basic setup in kernel_init\n"); // wait here
    .........
}
```

![](img/5-exit_mydelay.png)
![](img/5-mydelay.png)

`drivers/input/keyboard/atkbd.c` :

```c
.........
extern int exit_mydelay;  // declare as extern since it is defined in main.c
static irqreturn_t atkbd_interrupt(....){
    .............
    // detect 's' key pressed and change exit_mydelay
    if (code == 31) {
        printk("s pressed\n");
        exit_mydelay = 1;
    }
    .............
}
```

![](img/5-atkbd.png)

이후, 컴파일하고 재부팅하여 새로운 리눅스 커널을 적용하였다.

![](img/5-boot.png)

부팅 시 "enter s to continue"라는 메세지와 함께 사용자의 입력을 기다리고 있다.

![](img/5-after_s.png)

's'를 입력하면 부팅이 이어서 진행된다.

#### 5-1) Add mydelay before `do_basic_setup()`. What happens and why?

<br>

`init/main.c` :

```c
void kernel_init(){
    ...............
    mydelay("before do basic setup in kernel_init\n"); // wait here
    do_basic_setup();
    mydelay("after do basic setup in kernel_init\n"); // wait here
    .........
}
```

![](img/5-1.png)

이후, 컴파일하고 재부팅하여 새로운 리눅스 커널을 적용하였다.

부팅하면 `mydelay()` 함수가 실행되어 아래와 같은 메세지를 볼 수 있다.

![](img/5-1-before.png)

하지만, `do_basic_setup()` 함수가 실행되기 전에는 키보드 입력이 불가하여 's'를 입력할 수 없었고, 이후의 부팅 과정을 이어서 실행할 수 없었다.

### 6) Which function call in `atkbd_interrupt()` actually displays the pressed key in the monitor?

<br>

`drivers/input/keyboard/atkbd.c`:
![](img/3-atkbd.png)

키보드로 입력한 key를 찾는 [Prob 3)](#3-change-the-kernel-such-that-it-prints-x-pressed-for-each-key-pressing-where-x-is-the-scan-code-of-the-key-after-you-change-the-kernel-and-reboot-it-do-followings-to-see-the-effect-of-your-changing)에서 `drivers/input/keyboard/atkbd.c`에 `printk("%x pressed\n", code);`를 추가한 것으로 미루어보아, <br>
키를 화면에 출력하는 함수는 `code` 변수를 인자로 가져야할 것이라고 유추할 수 있다.

그래서 대입, 비교, 조건문에 쓰인 `code` 변수를 제외하고 관련된 함수들을 아래와 같이 모두 찾아보았다.

![](img/6-keycode.png)

또한 `code`를 이용하여 `keycode`라는 변수를 만들어 이용하기 때문에 `keycode` 변수를 인자로 갖는 함수도 찾아보았다.

![](img/6-input_event.png)
![](img/6-input_event2.png)
![](img/6-input_event3.png)
![](img/6-input_event4.png)

`input_event` 함수와 `input_report_key` 함수를 찾아보면 해답이 나올 것으로 보인다.

![](img/6-grep.png)

`include/linux/input.h`:
![](img/6-input_report_key.png)

`input_report_key` 함수 역시 `input_event` 함수를 활용한다는 것을 알 수 있다.

![](img/6-grep2.png)

`drivers/input/input.c`:

![](img/6-input.png)
`input_handle_event`가 event를 처리하는 함수라 추측하고 해당 파일 내에서 함수의 정의를 찾아보았다.

![](img/6-input_handle_event.png)
![](img/6-input_handle_event2.png)

해당 함수의 마지막줄에서 `input_pass_event` 함수에 `code` 변수를 인자로 넘기며 호출한다.

![](img/6-input_pass_event.png)
`input_pass_event` 함수의 정의를 보면, 해당 함수에서 `handler` 구조체의 `event`를 호출하는 것으로 보아, `atkbd_interrupt()` 내에서 `input_event`가 키를 모니터에 띄운다고 예상할 수 있다.

#### 6-1) What are the interrupt numbers for divide-by-zero exception, keyboard interrupt, and "read" system call? Where is ISR1 and ISR2 for each of them (write the exact code location)? Show their code, too.

|                          | Interrupt Number | ISR1         | ISR2            |
| ------------------------ | ---------------- | ------------ | --------------- |
| divide-by-zero exception | 0                | divide_error | do_divide_error |
| keyboard interrupt       | 33               | interrupt[1] | atkbd_interrupt |
| read system call         | 128              | system_call  | sys_read        |

|                       | location                         |
| --------------------- | -------------------------------- |
| ISR1                  | `arch/x86/kernel/entry_32.S`     |
| ISR2(do_divide_error) | `arch/x86/kernel/traps_32.c`     |
| ISR2(atkbd_interrupt) | `drivers/input/keyboard/atkbd.c` |
| ISR2(sys_read)        | `fs/read_write.c`                |

##### ISR1

divide-by-zero exception의 ISR1(divide_error)를 확인해보자.<br>
`arch/x86/kernel/entry_32.S`:
![](img/6-1-do_divide_error.png)

<br>

keyboard interrupt의 ISR1(interrupt[1])를 확인해보자.<br>
`arch/x86/kernel/entry_32.S`:
![](img/6-1-interrupt.png)

<br>

`read` system call의 ISR1(system_call)를 확인해보자.<br>
`arch/x86/kernel/entry_32.S`:
![](img/6-1-system_call.png)
...중간생략...
![](img/6-1-system_call3.png)

##### ISR2

keyboard interrupt의 ISR2(atkbd_interrupt) 실제 코드<br>
`arch/x86/kernel/traps_32.c`:
![](img/6-1-trap_init.png)
divide-by-zero exception의 ISR2(do_divide_error)가 `0`번인 것을 확인할 수 있다.

<br>

keyboard interrupt의 ISR2(atkbd_interrupt) 실제 코드<br>
`drivers/input/keyboard/atkbd.c`:
![](img/6-1-atkbd_interrupt.png)

<br>

`read` system call의 ISR2(sys_read)의 실제 코드<br>
`fs/read_write.c`:
![](img/6-1-sys_read.png)

### 7) `sys_call_table[]` is in `arch/x86/kernel/syscall_table_32.S`. How many system calls does Linux 2.6 support? <br>What are the system call numbers for `exit`, `fork`, `execve`, `wait4`, `read`, `write`, and `mkdir`? Find system call numbers for `sys_ni_syscall`, which is defined at `kernel/sys_ni.c`. What is the role of `sys_ni_syscall`?

```bash
$ vi arch/x86/kernel/syscall_table_32.S
```

`arch/x86/kernel/syscall_table_32.S` :
system calls들이 0부터 시작하여
![](img/7-syscall_table_Top.png)
326까지 있으므로
![](img/7-syscall_table_Bot.png)

Linux 2.6은 **327**개의 system call을 지원한다.

첫번째 스크린샷을 참고하면, `exit`는 1번, `fork`는 2번, `execve`는 11번, `read`는 3번, `write`는 4번이다.

![](img/7-wait4.png)
또한 `wait4`는 114번이고,

![](img/7-mkdir.png)
`mkdir`는 39번임을 알 수 있다.

![](img/7-sys_ni_syscall.png)
`sys_ni_call`은 시스템 콜 번호로 17, 31, 32번 등 여러 번호가 있는데 `kernel/sys_ni.c`로 가서 파일을 열어보면 아래와 같다.

`kernel/sys_ni.c` :
![](img/7-sys_ni.png)

`sys_ni_syscall`는 구현되지 않은 시스템 콜을 가리키는 함수이며 `-ENOSYS`을 반환한다. `ENOSYS`는 구현되지 않은 함수를 사용할 때 발생하는 오류 코드이다.

### 8) Change the kernel such that it prints "length 17 string found" for each `printf(s)` when the length of `s` is 17. Run a program that contains a `printf()` statement to see the effect. `printf(s)` calls `write(1, s, strlen(s))` system call which in turn runs

`printf(s)`는 내부적으로 `write(1, s, strlen(s))`를 호출한다. 따라서 `printf`를 호출할 때 같이 실행되는 코드를 삽입하기 위해서는 `write` 함수가 호출되는 시점을 알아야 한다.

`fs/read_write.c` :
![](img/8-sys_write.png)

`write` 함수는 `sys_write`를 호출하므로 `count`가 `17`인지 확인하는 코드를 삽입하면 된다.

커널을 컴파일하고 재부팅한다.

부팅 후, 아래와 같은 코드를 가지는 파일들을 만들었다.

`hello_world.c` :

```c
#include <stdio.h>

int main() {
  printf("Hello World!\n");
}
```

`ex.c` :

```c
#include <stdio.h>

int main() {
  printf("1234567890123456\n");
}
```

`ex.c`에서는 개행문자(`\n`)을 포함하여 17글자를 출력하도록 하였다.

![](img/8.png)

로그 레벨이 낮아 `printk` 출력이 보이지 않으므로 8로 수정했다.

임의의 17글자 문자열을 `printf로` 출력하게 한다. "Hello World!"는 17자가 아니어서 `printk`가 호출되지 않지만, "01234..."는 마지막의 개행문자(`\n`)까지 총 17자 이므로 "length 17 string found"가 출력되었다.

### 9) You can call a system call indirectly with `syscall()`.

```c
write(1, "hi", 2);
```

can be written as

```c
syscall(4, 1, "hi", 2); // 4 is the system call number for `write` system call
```

**Write a program that prints "hello" in the screen using syscall.**

#### Sol)

`ex2.c` :

```c
#include <stdio.h>

int main() {
    syscall(4, 1, "hello", 5); // 4 is the system call number for `write` system call
}
```

![](img/9.png)

### 10) Create a new system call, `my_sys_call` with system call number 17 (system call number 17 is one that is not being used currently). Define `my_sys_call()` just before `sys_write()` in `fs/read_write.c`. Write a program that uses this system call:

```c
void main(){
    syscall(17); // calls a system call with syscall number 17
}
```

**When the above program runs, the kernel should display**

```bash
hello from my_sys_call
```

#### Sol)

- To define a new system call with syscall number `x`
  - insert the new system call name in `arch/x86/kernel/syscall_table_32.S` at index `x`
    - ![](img/10-table.png)
  - define the function in appropriate file (such as `fs/read_write.c`)
    - ![](img/10.png)
    ```c
    asmlinkage void my_sys_call(){
        printk("hello from my_sys_call\n");
    }
    ```
  - recompile and reboot<br><br>
- To use this system call in a user program
  ```c
  void main(){
      syscall(x);
  }
  ```
  - ![](img/10-ex.png)

#### 10-1) Create another system call that will add two numbers given by the user.

Suppose 31 is an empty entry in sys_call_table.

`arch/x86/kernel/syscall_table_32.S` :
![](img/10-1-table.png)

31번 자리에 새로운 system call인 `my_sys_sum`으로 변경해주었다.

`fs/read_write.c` :
![](img/10-1-my_sys_sum.png)

`ex2.c` :

```c
void main(){
    int sum;
    sum = syscall(31, 4, 9);  // suppose 31 is an empty entry in sys_call_table
    printf("sum is %d\n", sum);
}
```

![](img/10-1-ex.png)

### 11) Modify the kernel such that it displays the system call number for all system calls. Run a simple program that displays "hello" in the screen and find out what system calls have been called. Also explain for each system call why that system call has been used.

Suppose 31 is an empty entry in sys_call_table.

`arch/x86/kernel/syscall_table_32.S` :
![](img/11-table.png)

31번 자리에 새로운 system call인 `my_sys_call_num`으로 변경해주었다.

`fs/read_write.c` :
![](img/11-my_sys_call_num.png)

`arch/x86/kernel/entry_32.S` :
![](img/11-entry.png)
`syscall_call` 아래에 `my_sys_call_num`를 호출하는 어셈블리 코드르 삽입한다. 함수에 첫 번째 인자로 시스템 콜 번호를 전달하기 위해 호출 전 `pushl %eax`를 한다. 함수 호출이 끝나면 `popl %eax`으로 레지스터 상태를 되돌려 놓았다.

![](img/11-hello.png)

위와 같이 시스템 함수들이 호출되는 것을 볼 수 있다.

### 12) What system calls are being called when you remove a file? Use `system()` function to run a Linux command as below. Explain what each system call is doing. You need to make `f1` file before you run it. Also explain for each system call why that system call has been used.

```c
   ...........
   system("rm f1");
   ...........
```

### 13) Find `rm.c` in `busybox-1.31.1` and show the code that actually removes `f1`. Note all linux commands are actually a program, and running `rm` command means running rm.c program. `rm` needs a system call defined in `uClibc-0.9.33.2` to remove a file. You may want to continue the code tracing all the way up to "INT 0x80" in uClibc for this system call.
