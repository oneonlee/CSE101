# -*- coding: utf-8 -*-
"""Floyd's_Algorithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19jnBGY9aPDYf8Zrsyt49SGfj2YEN-XbB
"""

def floyd2(n, W):
  D = W                                 # 최단 경로의 길이가 포함된 배열
  P = [[0] * (n+1) for _ in range(n+1)] # 최단 경로를 나타내는 배열

  for k in range(1, n+1):
    for i in range(1, n+1):
      for j in range(1, n+1):
        if D[i][k] + D[k][j] < D[i][j]: # k를 거쳐가는 경로가 최단경로일 경우
          P[i][j] = k                 # P[i][j]에 k가 거쳐간다고 기록
          D[i][j] = D[i][k] + D[k][j] # D[i][j]를 k를 거쳐가는 길이로 수정
        else: # k를 거치지 않는 경우가 최단경로일 경우
          pass # D[i][j], P[i][j] 를 수정하지 않음

  return D, P

def path(P, q, r): # q: 출발 정점, r: 도착 정점
  if P[q][r] == 0:  # 만약 주어진 경로의 칸의 값이 0인 경우
    pass  # 그냥 직선이 가장 좋은 경우이므로 pass
  else:             # 만약 0이 아니라면, 해당 칸을 전후로 나누어 
    path(P, q, P[q][r]) # "시작 지점 -> 해당 지점"을 재귀함수로 호출
    print(f" v{P[q][r]}", end=" ->")
    path(P, P[q][r], r) # "해당 지점 -> 끝 지점"을 재귀함수로 호출

def solution(n, W, q, r):
  D, P = floyd2(n, W)

  print("D[i][j] is")
  for row in range(1, len(D)):
      for col in range(1, len(D)):
        print(D[row][col], end=' ')
      print()

  print("\nP[i][j] is")
  for row in range(1, len(P)):
      for col in range(1, len(P)):
        print(P[row][col], end=' ')
      print()
      
  # 최단 경로 출력
  print(f"\nThe shortest path({q}, {r}) is", end=' ')
  print(f"v{q}", end=' ->')
  path(P, q, r)
  print(f" v{r}", end=' ')

INF = 999
W = [ # 가중치를 포함한 방향성 그래프
      [  0,   1,   2,   3,   4,   5],
      [  1,   0,   1, INF,   1,   5],
      [  2,   9,   0,   3,   2, INF],
      [  3, INF, INF,   0,   4, INF],
      [  4, INF, INF,   2,   0,   3],
      [  5,   3, INF, INF, INF,   0]
    ]

n = 5 # 그래프에서의 정점의 수

# v5 -> v3인 경우
solution(n, W, 5, 3)

# v1 -> v3인 경우
solution(n, W, 1, 3)

# v2 -> v5인 경우
solution(n, W, 2, 5)

