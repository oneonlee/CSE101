# -*- coding: utf-8 -*-
"""number_board_game.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IEr_wAaXmydxADEfRNtWtrjGYAv3c8Jl
"""

from copy import deepcopy

def solution(array):
  dp = deepcopy(array) # python의 copy 모듈을 사용하여 deepcopy 수행함으로서, 원본 데이터인 array를 보존

  # trace는 전의 행 중, 어떤 행에서 내려왔는지에 대한 index(행, 열 쌍)를 담는 리스트
  trace = [[0 for col in range(len(dp[0]))] for row in range(len(dp))]  # 빈 2차원 리스트 생성
  
  for i in range(1, len(dp)): # i는 행을 의미, 첫 0행은 합을 계산할 것이 없으므로 1부터 시작
    for j in range(len(dp[0])): # j는 열을 의미
      if j==0: # j가 0일 때는 바로 위쪽이나, 바로 오른쪽 대각선 위에서만 내려올 수 있다.
        if dp[i-1][j] < dp[i-1][j+1]: # 바로 오른쪽 대각선 위에서 내려왔을 경우
          max_val = dp[i-1][j+1]
          trace[i][j] = [i-1, j+1]
        else: # 바로 위쪽에서 내려왔을 경우
          max_val = dp[i-1][j]
          trace[i][j] = [i-1, j]

      elif j==len(dp[0])-1: # j가 배열의 끝일 때는 바로 위쪽이나, 바로 왼쪽 대각선 위에서만 내려올 수 있다.
        if dp[i-1][j-1] < dp[i-1][j]: # 바로 위쪽에서 내려왔을 경우
          max_val = dp[i-1][j]
          trace[i][j] = [i-1, j]
        else: # 바로 왼쪽 대각선 위에서 내려왔을 경우
          max_val = dp[i-1][j-1]
          trace[i][j] = [i-1, j-1]
      
      else: # j가 배열의 처음이나 끝이 아닐 때
        if dp[i-1][j-1] >= dp[i-1][j] and dp[i-1][j-1] >= dp[i-1][j+1]: # 바로 왼쪽 대각선 위에서 내려왔을 경우
          max_val = dp[i-1][j-1]
          trace[i][j] = [i-1, j-1]
        elif dp[i-1][j] >= dp[i-1][j+1]: # 바로 위쪽에서 내려왔을 경우
          max_val = dp[i-1][j]
          trace[i][j] = [i-1, j]
        else: # 바로 오른쪽 대각선 위에서 내려왔을 경우
          max_val = dp[i-1][j+1]
          trace[i][j] = [i-1, j+1]

      dp[i][j] = max_val + dp[i][j] # dp 배열을 자기자신에 최대값을 더한 합으로 갱신

  max_idx = dp[-1].index(max(dp[-1]))
  back_tracking = [] # 숫자들이 내려온 경로의 합이 최대인 경로의 위치정보(index)를 거꾸로 담는 리스트
  back_tracking.append([len(dp)-1, max_idx]) # 최종 경로의 합의 최대값의 위치
  for idx in reversed(range(1, len(dp))): # 거꾸로 담기 때문에 reversed를 사용해 for문을 역순으로 순회
    back_tracking.append(trace[idx][max_idx])
    max_idx = back_tracking[-1][1]
  back_tracking.reverse() # 끝에서부터(숫자판의 아래) 거꾸로 되어있는 리스트를 처음부터(숫자판의 위) 출력되도록 뒤집어줌

  print("숫자들이 내려온 경로의 합이 최대인 경로")
  for cell in back_tracking:
    print(array[cell[0]][cell[1]], end=" ")
  print()
  print("숫자들이 내려온 경로의 합의 최대값")
  print(max(dp[-1]))

array = [
          [3, 4, 9, -2, 2, 51, -23, 2, -1],
          [223, 7, 8, -11, 5, -99, 2, 3, -4],
          [2, 51, -23, -23, 6, 3, 2, 4, 5],
          [5, -99, 2, -1, 32, 2, 5, -99, 2],
          [6, 3, 3, -4, 2, -1, 6, 3, 3],
          [32, 2, 4, 5, 3, -4, 2, -1, 4],
          [4, 4, 23, 6, 2, -1, 3, -4, 34],
          [78, 32, 1, 7, 3, -4, -23, -23, 6],
        ];

solution(array)