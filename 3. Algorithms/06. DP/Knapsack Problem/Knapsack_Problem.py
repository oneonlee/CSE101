# -*- coding: utf-8 -*-
"""Knapsack Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ifr-fy1Lkmz8iJWNQrCNinnrsQyuuMm7
"""

# max_W: 배낭의 최대 용량, N: 보석의 수, weight: 각 보석의 무게, value: 각 보석의 가치
def knapsack_problem(max_W, N, weight, value):  
    # DP를 위해 2차원 리스트 P를 0으로 초기화
    P = [[0 for x in range(max_W+1)] for x in range(N+1)]

    # 0번째 보석의 자리는 비워져 있으므로 for문을 1부터 시작함
    for i in range(1, N+1):
        for w in range(1, max_W+1):
            # P[i][w]에 대한 점화식 구현
            # P[i][w] : i개의 아이템을 골랐을 때, w 무게에서의 최대 가치
            
            # 현재 물건이 가방이 담을 수 있는 무게보다 작아서 물건을 포함할 수 있다면
            if weight[i] <= w: 
                # 둘 중 최고의 이익(max) 선택
                P[i][w] = max(P[i-1][w], value[i]+P[i-1][w-weight[i]])  
            # 현재 물건이 가방이 담을 수 있는 무게보다 작아서 물건을 포함할 수 없다면 
            else: 
                P[i][w] = P[i-1][w] # 이전 값을 그대로 가져옴
    # 가방에 담을 수 있는 최대 무게에서 모든 물건을 고려했을 때의 최대값을 출력
    return P[N][max_W]

# 입력 1
max_W = 15
gem_list = [(5, 5), (10, 7), (7, 10), (3, 6), (4, 8), (11, 20)]
N = len(gem_list)

# 0번째 보석의 자리는 비워둠
weight = [0]
value = [0] 

for i in range(len(gem_list)):
    weight.append(gem_list[i][0])
    value.append(gem_list[i][1])

print("입력 1에 대하여 가방에 담은 보석의 최대 가치: ", end='')
print(knapsack_problem(max_W, N, weight, value))

# 입력 2
max_W = 30
gem_list = [(3, 5), (7, 7), (8, 10), (5, 6), (6, 8), (13, 20), (11, 18), (2, 5)]
N = len(gem_list)

# 0번째 보석의 자리는 비워둠
weight = [0]
value = [0] 

for i in range(len(gem_list)):
    weight.append(gem_list[i][0])
    value.append(gem_list[i][1])

print("입력 2에 대하여 가방에 담은 보석의 최대 가치: ", end='')
print(knapsack_problem(max_W, N, weight, value))