# -*- coding: utf-8 -*-
"""cheese_and_trap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C-UFBJN3wcnBYs6jXWaM2z6Fa9ZjF5GX
"""

def solution(p):
    # r은 row(행), c는 column(열)을 의미

    m = len(p)    # 구성된 미로의 행의 크기
    n = len(p[0])  # 구성된 미로의 열의 크기

    # 구성된 미로와 크기가 같은 빈 2차원 리스트 생성
    # dp 배열은 제한조건에 따라 주어진 미로의 임의의 자리까지 움직였을 때, 먹을 수 있는 치즈의 최대값을 나타냄
    dp = [[0 for col in range(n)] for row in range(m)]

    # 주어진 미로에서 가장 아래줄(0행)과 가장 왼쪽줄(0열)은 각각 왼쪽과 아래쪽에서만 올 수 있으므로,
    # 이 2가지 경우들은 따로 처리를 해준다.

    # Case 1 - 가장 아래줄(0행) : 왼쪽에서만 오른쪽으로만 갈 수 있다.
    for r in range(1, m):
        if (p[0][r] == -1):    # 미로의 해당 자리에 아무것도 없는 경우
            dp[0][r] = dp[0][r-1] + 0
        elif (p[0][r] == 1):  # 미로의 해당 자리에 치즈가 있는 경우
            dp[0][r] = dp[0][r-1] + 1
        elif (p[0][r] == 2):  # 미로의 해당 자리에 덫이 있는 경우
            dp[0][r] = -100

    # Case 2 - 가장 왼쪽줄(0열) : 아래쪽에서 위로만 올라올 수 있다.
    for c in range(1, n):
        if (p[c][0] == -1):    # 미로의 해당 자리에 아무것도 없는 경우
            dp[c][0] = dp[c-1][0] + 0
        elif (p[c][0] == 1):  # 미로의 해당 자리에 치즈가 있는 경우
            dp[c][0] = dp[c-1][0] + 1
        elif (p[c][0] == 2):  # 미로의 해당 자리에 덫이 있는 경우
            dp[c][0] = -100

    # Case 3 - Case 1과 2를 제외한 모든 경우 : 오른쪽 혹은 위쪽으로 움직일 수 있다.
    for r in range(1, m):
        for c in range(1, n):
            if (p[c][r] == -1):    # 미로의 해당 자리에 아무것도 없는 경우
                # 왼쪽과 아래쪽 중 더 큰 것을 선택한다.
                dp[c][r] = max(dp[c - 1][r], dp[c][r - 1]) + 0
            elif (p[c][r] == 1):  # 미로의 해당 자리에 치즈가 있는 경우
                # 왼쪽과 아래쪽 중 더 큰 것을 선택하고, 치즈가 있으므로 1을 더해준다.
                dp[c][r] = max(dp[c - 1][r], dp[c][r - 1]) + 1
            elif (p[c][r] == 2):  # 미로의 해당 자리에 덫이 있는 경우
                dp[c][r] = -100

    return dp[n-1][m-1]  # 출구에서의 dp 배열값을 반환

# 미로에서 -1은 아무것도 없는 곳, 1은 치즈가 있는 곳, 2는 쥐덫이 있는 곳을 의미한다.
# 주어진 미로에서 p[0][0]의 위치는 왼쪽 아래이므로, 미로를 뒤집어주었다.

p = [
      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
      [-1, -1, -1, -1, -1, 1, -1, -1, -1],
      [-1, 1, -1, -1, 1, -1, -1, -1, -1],
      [-1, -1, -1, -1, -1, 2, 1, 2, -1],
      [-1, 1, -1, 1, -1, -1, -1, -1, -1],
      [-1, -1, -1, -1, 1, 2, -1, -1, -1],
      [1, -1, 2, -1, -1, -1, -1, 1, -1],
      [-1, -1, -1, -1, -1, 1, -1, 2, -1],
      [-1, -1, 1, -1, -1, -1, -1, -1, -1]
    ]

print(f"최대 {solution(p)}개의 치즈를 먹을 수 있다.")

